(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = require('./lib/heap');

},{"./lib/heap":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);

},{}],3:[function(require,module,exports){
let Algorithm = require("./Algorithm");

/**
 * A* algorithm extending Algorithms class
 *
 * Reference for A* Algorithm and comparison to Dijkstra:
 * http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
 */
class AStar extends Algorithm {
  /**
   * using manhattan distance for heuristic (for square grid without diagonal movement)
   * @param {Node} currentNode
   * @param {Node} endNode
   */
  heuristic(currentNode, endNode) {
    let xDiff = Math.abs(currentNode.x - endNode.x);
    let yDiff = Math.abs(currentNode.y - endNode.y);
    return xDiff + yDiff;
  }
}

module.exports = AStar;

},{"./Algorithm":4}],4:[function(require,module,exports){
var Heap = require("heap");

/**
 * Algorithm class based on: https://github.com/bgrins/javascript-astar
 * Reused components and made modifications/adaptations to suit our use case.
 */
class Algorithm {
  /**
   * Javascript by default doesn't have abstract classes.
   * Heuristic-method must be implemented when extending this class.
   * If not, it will throw an error (clean way -> use TypeScript instead of JavaScript)
   */
  constructor() {
    if (this.heuristic === undefined)
      throw new Error(
        "Cannot extend Algorithms class, must implement heuristic method"
      );
  }

  /**
   * Find and returns the shortest path
   */
  findShortestPath = (grid, getVisitedElement) => {
    let startNode = grid.getNode(grid.startPoint);
    let endNode = grid.getNode(grid.endPoint);
    let node, allCurrentNeighbors, neighbor;
    let nodeList = new Heap((first, next) => first.fCost - next.fCost);

    startNode.gCost = 0;
    startNode.fCost = 0;

    nodeList.push(startNode);
    startNode.opened = true;

    while (!nodeList.empty()) {
      node = nodeList.pop(); // gets next node
      node.closed = true;

      // returns shortest path if end was reached
      if (node === endNode) return this.shortestPath(endNode);

      allCurrentNeighbors = grid.getNeighbors(node); // get neigbours of the current node
      for (let i = 0; i < allCurrentNeighbors.length; ++i) {
        neighbor = allCurrentNeighbors[i];
        if (neighbor.closed) continue;

        // get the distance between current node and the neighbor and calculate the next g score
        let nextGCost = (node.gCost + 1) * neighbor.weight; // only top/bottom/left/right movement

        // Check if neighbor was not visited yet and has smaller cost
        if (!neighbor.opened || nextGCost < neighbor.gCost) {
          neighbor.hCost = neighbor.hCost || this.heuristic(neighbor, endNode);

          neighbor.gCost = nextGCost;
          neighbor.fCost = neighbor.gCost + neighbor.hCost;
          neighbor.parent = node;

          nodeList.push(neighbor);
          getVisitedElement(neighbor);
          neighbor.opened = true;
        }
      }
    }

    return null; // if it cannot find any path, return empty list
  };

  /**
   * creates shortest path in right order (from start to end)
   */
  shortestPath = (endNode) => {
    let shortestPath = [{ x: endNode.x, y: endNode.y }];
    while (endNode.parent != null) {
      endNode = endNode.parent;
      shortestPath.push({ x: endNode.x, y: endNode.y });
    }
    let shortestPathReversed = shortestPath.reverse();
    return shortestPathReversed;
  };
}

module.exports = Algorithm;

},{"heap":1}],5:[function(require,module,exports){
let Algorithm = require("./Algorithm");

/**
 * Dijkstra algorithm extending Algorithms class
 *
 * Reference for Dijkstra algorithm:
 * Introduction to Algorithms, Third Edition page 658
 *
 * Reference for comparison to A* Algorithm:
 * http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
 */
class Dijkstra extends Algorithm {
  /**
   * heuristic returns 0 since Dijkstra's algorithm doesn't take shortest
   * x/y difference into account
   */
  heuristic() {
    return 0;
  }
}

module.exports = Dijkstra;

},{"./Algorithm":4}],6:[function(require,module,exports){
let { events, htmlElement, timeouts, cellTypes } = require("./Models");

class EventListener {
  callback = () => _;

  /**
   * Creates and calls all neccessary html events
   * @param {GuiController} guiController instance for manipulating grid data
   */
  constructor(guiController) {
    this.guiController = guiController;

    window.addEventListener(events.load, () => {
      this.guiController.htmlActions.setGrid();
      this.createListeners();
    });
  }

  /**
   * Creates all html button listeners
   */
  createListeners = () => {
    this.onClearButtonClicked();
    this.onStartAlgorithmButtonClicked();
    this.onChooseStartPointButtonClicked();
    this.onChooseEndPointButtonClicked();
    this.onSetWeights();
    this.onAstartClicked();
    this.onDijkstraClicked();
    this.onOtherClicked();
    this.onSlowMotion();
    this.onEraseClicked();
  };

  /**
   * Executed once clear button is clicked
   */
  onClearButtonClicked = () => {
    document
      .getElementById(htmlElement.clearButton)
      .addEventListener(events.click, () => {
        console.log("Clear button clicked");
        this.guiController.clearGrid();
      });
  };

  /**
   * Executed once start algorithm button is clicked
   */
  onStartAlgorithmButtonClicked = () => {
    document
      .getElementById(htmlElement.startAlgorithmButton)
      .addEventListener(events.click, () => {
        console.log("Start algorithm button clicked");
        if (!this.guiController.alreadyExecuted)
          this.guiController.startAlgorithm(this.guiController.algorithm);
      });
  };

  /**
   * Executed once choose start point button is clicked
   */
  onChooseStartPointButtonClicked = () => {
    document
      .getElementById(htmlElement.startPointButton)
      .addEventListener(events.click, () => {
        console.log("Choosing start point");
        this.guiController.choosingStartPoint = true;
        this.guiController.choosingEndPoint = false;
        this.guiController.choosingObstacle = false;
        this.guiController.erasing = false;
      });
  };

  /**
   * Executed once choose end point button is clicked
   */
  onChooseEndPointButtonClicked = () => {
    document
      .getElementById(htmlElement.endPointButton)
      .addEventListener(events.click, () => {
        console.log("Choosing end point");
        this.guiController.choosingStartPoint = false;
        this.guiController.choosingEndPoint = true;
        this.guiController.choosingObstacle = false;
        this.guiController.erasing = false;
      });
  };
  
  /**
   * Executed once A* Algorithm button is clicked
   */
  onAstartClicked = () => {
    document
      .getElementById(htmlElement.astar)
      .addEventListener(events.click, () => {
        console.log("Setting algorithm to AStart");
        this.guiController.algorithm = this.guiController.astar;
      });
  };

  /**
   * Executed once Dijkstra Algorithm button is clicked
   */
  onDijkstraClicked = () => {
    document
      .getElementById(htmlElement.dijkstra)
      .addEventListener(events.click, () => {
        console.log("Setting algorithm to Dijkstra");
        this.guiController.algorithm = this.guiController.dijkstra;
      });
  };

  /**
   * Executed once "other" button is clicked
   */
  onOtherClicked = () => {
    document
      .getElementById(htmlElement.other)
      .addEventListener(events.click, () => {
        alert("More algorithms comming soon!");
        if (this.guiController.algorithm == this.guiController.dijkstra)
          document.getElementById(htmlElement.dijkstra).checked = true;
        else document.getElementById(htmlElement.astar).checked = true;
      });
  };

  /**
   * Executed once one of the slow motion selection is clicked
   */
  onSlowMotion = () => {
    document
      .getElementById(htmlElement.slowMotionNormal)
      .addEventListener(
        events.click,
        () => (this.guiController.timeout = timeouts.default)
      );
    document
      .getElementById(htmlElement.slowMotionSlow)
      .addEventListener(
        events.click,
        () => (this.guiController.timeout = timeouts.slow)
      );
    document
      .getElementById(htmlElement.slowMotionVerySlow)
      .addEventListener(
        events.click,
        () => (this.guiController.timeout = timeouts.verySlow)
      );
  };

  /**
   * Executed once one of the elements selection is clicked
   */
  onSetWeights = () => {
    document
      .getElementById(htmlElement.obstacleWall)
      .addEventListener(events.click, () => {
        this.guiController.choosingStartPoint = false;
        this.guiController.choosingEndPoint = false;
        this.guiController.choosingObstacle = true;
        this.guiController.erasing = false;
        this.guiController.weightsActive = false;
        console.log(`Setting obstacle to: ${cellTypes.wall}`);
        this.guiController.currentWeight = cellTypes.wall;
      });
    document
      .getElementById(htmlElement.obstacleLight)
      .addEventListener(events.click, () => {
        this.guiController.choosingStartPoint = false;
        this.guiController.choosingEndPoint = false;
        this.guiController.choosingObstacle = true;
        this.guiController.erasing = false;
        this.guiController.weightsActive = true;
        console.log(`Setting obstacle to: ${cellTypes.obstacleLight}`);
        this.guiController.currentWeight = cellTypes.obstacleLight;
      });
    document
      .getElementById(htmlElement.obstacleMedium)
      .addEventListener(events.click, () => {
        this.guiController.choosingStartPoint = false;
        this.guiController.choosingEndPoint = false;
        this.guiController.choosingObstacle = true;
        this.guiController.erasing = false;
        this.guiController.weightsActive = true;
        console.log(`Setting obstacle to: ${cellTypes.obstacleMedium}`);
        this.guiController.currentWeight = cellTypes.obstacleMedium;
      });
    document
      .getElementById(htmlElement.obstacleHeavy)
      .addEventListener(events.click, () => {
        this.guiController.choosingStartPoint = false;
        this.guiController.choosingEndPoint = false;
        this.guiController.choosingObstacle = true;
        this.guiController.erasing = false;
        this.guiController.weightsActive = true;
        console.log(`Setting obstacle to: ${cellTypes.obstacleHeavy}`);
        this.guiController.currentWeight = cellTypes.obstacleHeavy;
      });
  };
  
  /**
   * Exectued once erase button is clicked
   */
  onEraseClicked = () => {
    document
      .getElementById(htmlElement.eraseButton)
      .addEventListener(events.click, () => {
        console.log("Erase button clicked");
        this.guiController.choosingStartPoint = false;
        this.guiController.choosingEndPoint = false;
        this.guiController.choosingObstacle = false;
        this.guiController.erasing = true;
    });
  };
  
}

module.exports = EventListener;

},{"./Models":10}],7:[function(require,module,exports){
/**
 *
 * Grid class based on: https://github.com/bgrins/javascript-astar
 * Reused components and made modifications/adaptations to suit our use case.
 *
 * The Grid class, encapsulates layout of nodes.
 * Converts 2d matrix into adjacency graph
 */
class Grid {
  startPoint = {
    x: undefined,
    y: undefined,
  };
  endPoint = {
    x: undefined,
    y: undefined,
  };

  constructor() {}

  /**
   * Builds the nodes.
   */
  buildNodesFromMatrix = (matrix) => {
    this.height = matrix.length;
    this.width = matrix[0].length;
    let nodes = [];

    for (let i = 0; i < this.height; ++i) {
      nodes[i] = [];
      for (let j = 0; j < this.width; ++j) {
        nodes[i][j] = new Node(j, i);
      }
    }

    for (let i = 0; i < this.height; ++i) {
      for (let j = 0; j < this.width; ++j) {
        if (matrix[i][j] === 1) nodes[i][j].walkable = false;
      }
    }
    this.nodes = nodes;
  };

  /**
   * Returns cell of matrix [row][column]
   */
  getNode = (node) => {
    return this.nodes[node.y][node.x];
  };

  /**
   * Returns weight of given node
   */
  getWeight = (x, y) => {
      return this.nodes[y][x].weight;
  }

  /**
   * Sets weight of given node
   */
  setWeight = (x, y, weight) => {
    this.nodes[y][x].weight = weight;
  };

  /**
   * Returns true if position is inside of the grid and walkable
   */
  reachable = (x, y) => {
    return this.insideGrid(x, y) && this.nodes[y][x].walkable;
  };

  /**
   * Determines whether position is inside grid.
   */
  insideGrid = (x, y) => {
    let withinXBorder = x >= 0 && x < this.width;
    let withinYBorder = y >= 0 && y < this.height;
    return withinXBorder && withinYBorder;
  };

  /**
   * Gets neighbors of node
   * @todo: add diagonal movement
   */
  getNeighbors = (node) => {
    let x = node.x;
    let y = node.y;
    let neighbors = [];
    let nodesList = this.nodes;

    // top
    let top = y - 1;
    if (this.reachable(x, top)) neighbors.push(nodesList[top][x]);

    // right
    let right = x + 1;
    if (this.reachable(right, y)) neighbors.push(nodesList[y][right]);

    // bottom
    let bottom = y + 1;
    if (this.reachable(x, bottom)) neighbors.push(nodesList[bottom][x]);

    // left
    let left = x - 1;
    if (this.reachable(left, y)) neighbors.push(nodesList[y][left]);

    return neighbors;
  };
}

/**
 * Creates a node based on its coordinates.
 * Default: walkable = true & weight = 1
 */
class Node {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.walkable = true;
    this.weight = 1;
  }
}

module.exports = Grid;

},{}],8:[function(require,module,exports){
let Grid = require("./Grid");
let Dijkstra = require("./Dijkstra");
let AStar = require("./AStar");
let HTMLActions = require("./HTMLActions");
let EventListener = require("./EventListener");
let { timeouts, obstacleWeights, cellTypes, gridSize } = require("./Models");

class GuiController {
  visited = new Array();
  weights = new Array();
  typeOfCell;
  timeout = timeouts.default;
  timeWaited = 0;

  alreadyExecuted = false;
  choosingStartPoint = true;
  choosingEndPoint = false;
  choosingObstacle = false;
  erasing = false;
  weightsActive = false;
  currentWeight = "";

  /**
   * sets up Gui controller
   */
  constructor() {
    console.log("Gui controller created");
    this.matrix = this.createMatrix(24);
    this.dijkstra = new Dijkstra();
    this.astar = new AStar();
    this.algorithm = this.dijkstra;
    this.inputGrid = new Grid();
  }

  /**
   * sets up grid html component
   */
  setup = () => {
    this.grid = HTMLActions.createGrid(
      gridSize.row,
      gridSize.column,
      this.onGridClicked
    );

    this.htmlActions = new HTMLActions(this.grid);
    let eventListener = new EventListener(this);
  };

  onGridClicked = (element, selectedRow, selectedColumn) => {
    element.className = "clicked";
    if (this.choosingObstacle) {
      this.eraseElement(selectedColumn, selectedRow); //Erase element called to avoid duplicate weights and invisible walls
      this.setObstacle(selectedColumn, selectedRow);
    } else if (this.choosingEndPoint) {
      this.setEndPoint(selectedColumn, selectedRow);
    } else if (this.choosingStartPoint) {
      this.setStartPoint(selectedColumn, selectedRow);
    } else {
      this.eraseElement(selectedColumn, selectedRow);
    }
  };

  /**
   * Adds visited element to list
   * @param {number} row represents y coord
   * @param {number} column represents x coord
   */
  getVisitedElement = (node) => {
    this.visited.push({ x: node.x, y: node.y });
  };

  /**
   * creates matrix representation of grid with row and columns
   * @param {number} rows
   */
  createMatrix = (rows) => {
    /**
     * If walls are added, change matrix cell to 1
     */
    let matrix = new Array(rows);
    this.typeOfCell = new Array(rows);
    for (let i = 0; i < rows; i++) {
      matrix[i] = new Array(rows);
      this.typeOfCell[i] = new Array(rows);
      for (let j = 0; j < rows; j++) {
        matrix[i][j] = 0;
        this.typeOfCell[i][j] = cellTypes.plain;
      }
    }
    return matrix;
  };

  /**
   * sets startpoint
   * @param {number} row represents y coord
   * @param {number} col represents x coord
   */
  setStartPoint = (row, col) => {
    if (this.inputGrid.startPoint.x !== undefined) {
      this.htmlActions.setElement(
        this.inputGrid.startPoint.x,
        this.inputGrid.startPoint.y,
        cellTypes.plain
      );
      this.typeOfCell[this.inputGrid.startPoint.y][
        this.inputGrid.startPoint.x
      ] = cellTypes.plain;
    }
    this.inputGrid.startPoint = { x: col, y: row };
    this.htmlActions.setElement(
      this.inputGrid.startPoint.x,
      this.inputGrid.startPoint.y,
      cellTypes.start
    );
    this.typeOfCell[row][col] = cellTypes.start;
    console.log(
      `startpoint: (${this.inputGrid.startPoint.x}, ${this.inputGrid.startPoint.y})`
    );
  };

  /**
   * sets endpoint
   * @param {number} row represents y coord
   * @param {number} col represents x coord
   */
  setEndPoint = (row, col) => {
    if (this.inputGrid.endPoint.x !== undefined) {
      this.htmlActions.setElement(
        this.inputGrid.endPoint.x,
        this.inputGrid.endPoint.y,
        cellTypes.plain
      );
      this.typeOfCell[this.inputGrid.endPoint.y][this.inputGrid.endPoint.x] =
        cellTypes.plain;
    }
    this.inputGrid.endPoint = { x: col, y: row };
    this.htmlActions.setElement(
      this.inputGrid.endPoint.x,
      this.inputGrid.endPoint.y,
      cellTypes.end
    );
    this.typeOfCell[row][col] = cellTypes.end;
    console.log(
      `endpoint: (${this.inputGrid.endPoint.x}, ${this.inputGrid.endPoint.y})`
    );
  };

  /**
   * sets obstacle (either wall or weights depending on user input)
   * @param {number} row represents y coord
   * @param {number} col represents x coord
   */
  setObstacle = (row, col) => {
    if (this.weightsActive == false) this.setWall(row, col);
    else this.setWeight(row, col);
  };

  /**
   * sets wall
   * @param {number} row represents y coord
   * @param {number} col represents x coord
   */
  setWall = (row, col) => {
    console.log(`Wall: (${col}, ${row})`);
    this.matrix[row][col] = 1;
    this.htmlActions.setElement(col, row, cellTypes.wall);
    this.typeOfCell[row][col] = cellTypes.wall;
  };

  /**
   * Sets weight
   * @param {number} row represents y coord
   * @param {number} col represents x coord
   */
  setWeight = (row, col) => {
    console.log(`Weight: (${col}, ${row}): ${this.currentWeight}`);
    this.weights.push({
      x: col,
      y: row,
      weight: obstacleWeights[this.currentWeight],
    });
    this.htmlActions.setElement(col, row, this.currentWeight);
    this.typeOfCell[row][col] = this.currentWeight;
  };

  /**
   * Removes a weight
   * @param {number} row represents y coord
   * @param {number} col represents x coord
   */
  removeWeight = (row, col) => {
    for (let i = 0; i < this.weights.length; i++) {
      let point = this.weights[i];
      if (point["x"] === col && point["y"] === row) {
        this.weights.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Erases an element
   * @param {number} row represents y coord
   * @param {number} col represents x coord
   */
  eraseElement = (row, col) => {
    let cellType = this.typeOfCell[row][col];
    switch (cellType) {
      case cellTypes.start:
        this.inputGrid.startPoint = { x: undefined, y: undefined };
        break;
      case cellTypes.end:
        this.inputGrid.endPoint = { x: undefined, y: undefined };
        break;
      case cellTypes.wall:
        this.matrix[row][col] = 0;
        break;
      default:
        if (
          cellType === cellTypes.obstacleLight ||
          cellType === cellTypes.obstacleHeavy ||
          cellType === cellTypes.obstacleMedium
        ) {
          this.removeWeight(row, col);
        }
    }
    this.htmlActions.setElement(col, row, cellTypes.plain);
    this.typeOfCell[row][col] = cellTypes.plain;
    console.log(`Erased: (${col}, ${row})`);
  };

  /**
   * clears grid from all ui changes and resets saved start/endpoint and walls
   */
  clearGrid = () => {
    console.log("Clearing grid");
    this.inputGrid.startPoint = { x: undefined, y: undefined };
    this.inputGrid.endPoint = { x: undefined, y: undefined };
    this.visited = [];

    for (let x = 0; x < this.matrix.length; x++) {
      for (let y = 0; y < this.matrix[0].length; y++) {
        this.typeOfCell[x][y] = cellTypes.plain;
        this.htmlActions.setElement(x, y, cellTypes.plain);
      }
    }
    this.alreadyExecuted = false;
    this.matrix = this.createMatrix(24);
    this.timeWaited = 0;
    this.currentWeight = "";
    this.weights = [];
    this.weightsActive = false;
    this.htmlActions.resetElementsUi();
  };

  /**
   * starts algorithms and draws shotest path and visited cells
   * @param {algorithm} algorithm which should be used for finding the shortest path
   */
  startAlgorithm = (algorithm) => {
    console.log("Starting algorithm");

    if (this.inputGrid.startPoint.x == null) {
      alert("Cannot start algorithm, choose startpoint first");
      return;
    }
    if (this.inputGrid.endPoint.x == null) {
      alert("Cannot start algorithm, choose endpoint first");
      return;
    }

    this.inputGrid.buildNodesFromMatrix(this.matrix);

    this.weights.forEach((data) => {
      this.inputGrid.setWeight(data.x, data.y, data.weight);
    });

    let shortestPath = algorithm.findShortestPath(
      this.inputGrid,
      this.getVisitedElement
    );

    /**
     * Animation for visited cells
     */
    this.visited.forEach((node, index) => {
      if (
        node.x == this.inputGrid.endPoint.x &&
        node.y == this.inputGrid.endPoint.y
      )
        return;
      if (
        node.x == this.inputGrid.startPoint.x &&
        node.y == this.inputGrid.startPoint.y
      )
        return;
      setTimeout(() => {
        if(this.typeOfCell[node.y][node.x] === cellTypes.obstacleLight){
          this.htmlActions.setElement(node.x, node.y, cellTypes.visitedLight);
        } else if(this.typeOfCell[node.y][node.x] === cellTypes.obstacleMedium){
          this.htmlActions.setElement(node.x, node.y, cellTypes.visitedMedium);
        } else if(this.typeOfCell[node.y][node.x] === cellTypes.obstacleHeavy){
          this.htmlActions.setElement(node.x, node.y, cellTypes.visitedHeavy);
        } else {
          this.htmlActions.setElement(node.x, node.y, cellTypes.visitedCell);
        }
      }, index * this.timeout);
      this.timeWaited++;
    });

    /**
     * Draws shortest path
     */
    setTimeout(() => {
      shortestPath.forEach((node) => {
        if (
          node.x == this.inputGrid.startPoint.x &&
          node.y == this.inputGrid.startPoint.y
        )
          return;
        if (
          node.x == this.inputGrid.endPoint.x &&
          node.y == this.inputGrid.endPoint.y
        )
          return;

        this.htmlActions.setElement(node.x, node.y, cellTypes.shortestPathCell);
      });
    }, this.timeWaited * this.timeout);
    
    this.alreadyExecuted = true;
  };
}

module.exports = GuiController;

},{"./AStar":3,"./Dijkstra":5,"./EventListener":6,"./Grid":7,"./HTMLActions":9,"./Models":10}],9:[function(require,module,exports){
let { colors, htmlElement, cellTypes, events } = require("./Models");

class HtmlActions {
  constructor(grid) {
    this.grid = grid;
  }

  /**
   * creates html representation of grid
   * @param {number} rows total number of grid rows
   * @param {number} cols total number of grid columns
   * @param {callback} callback which will be executed once a click event is recognized
   */
  static createGrid = (rows, cols, callback) => {
    var i = 0;
    let grid = document.createElement("table");
    grid.className = "grid";
    for (var r = 0; r < rows; ++r) {
      var tr = grid.appendChild(document.createElement("tr"));
      for (var c = 0; c < cols; ++c) {
        var cell = tr.appendChild(document.createElement("td"));
        cell.addEventListener(
          events.click,
          (function (el, r, c, i) {
            return function () {
              callback(el, r, c, i);
            };
          })(cell, r, c, i),
          false
        );
      }
    }
    return grid;
  };

  /**
   * sets up grid html component
   */
  setGrid = () => {
    let htmlGridDiv = document.getElementsByClassName(htmlElement.grid);
    let putHere = htmlGridDiv.item(0);
    putHere.appendChild(this.grid);
  };

  /**
   * Sets color of element depending on type
   * @param {number} x column value
   * @param {number} y row value
   * @param {cellType} type the element type (plain, start, end, wall or obstacle)
   */
  setElement = (x, y, type) => {
    let element = this.grid.rows[x].cells[y];

    switch (type) {
      case cellTypes.plain:
        element.style.backgroundColor = colors.plain;
        break;
      case cellTypes.wall:
        element.style.backgroundColor = colors.wall;
        break;
      case cellTypes.start:
        element.style.backgroundColor = colors.start;
        break;
      case cellTypes.end:
        element.style.backgroundColor = colors.end;
        break;
      case cellTypes.obstacleLight:
        element.style.backgroundColor = colors.obstacleLight;
        break;
      case cellTypes.obstacleMedium:
        element.style.backgroundColor = colors.obstacleMedium;
        break;
      case cellTypes.obstacleHeavy:
        element.style.backgroundColor = colors.obstacleHeavy;
        break;
      case cellTypes.visitedCell:
        element.style.backgroundColor = colors.visited;
        break;
      case cellTypes.visitedLight:
        element.style.backgroundColor = colors.visitedLight;
        console.log("light colored");
        break;
      case cellTypes.visitedMedium:
        element.style.backgroundColor = colors.visitedMedium;
        break;
      case cellTypes.visitedHeavy:
        element.style.backgroundColor = colors.visitedHeavy;
        break;
      case cellTypes.shortestPathCell:
        element.style.backgroundColor = colors.shortestPath;
        break;
    }
  };

  /**
   * Resets element selection on clearGrid to default to start point
   */
  resetElementsUi = () => {
    document.getElementById(htmlElement.startPointButton).click();
  };
}

module.exports = HtmlActions;

},{"./Models":10}],10:[function(require,module,exports){
/**
 * defines all colors currenlty used
 */
const colors = {
  start: "#82E0AA",
  end: "#D98880",
  visited: "#D6EAF8",
  wall: "#666666",
  shortestPath: "#FFEE58",
  plain: "white",
  obstacleLight: "#D9D9D9",
  obstacleMedium: "#B3B3B3",
  obstacleHeavy: "#8C8C8C",
  visitedLight: "#a8d2f0",
  visitedMedium: "#7cbce9",
  visitedHeavy: "#51a5e1"
};

/**
 * defines all html methods used
 */
const htmlElement = {
  grid: "col-md-9",
  clearButton: "clearButton",
  startAlgorithmButton: "startAlgorithmButton",
  startPointButton: "chooseStartButton",
  endPointButton: "chooseEndButton",
  dijkstra: "dijkstra",
  astar: "astart",
  other: "other",
  slowMotionNormal: "normal",
  slowMotionSlow: "twice",
  slowMotionVerySlow: "triple",
  obstacleWall: "one",
  obstacleLight: "two",
  obstacleMedium: "three",
  obstacleHeavy: "four",
  eraseButton: "erase"
};

/**
 * defines all possible cell types
 */
const cellTypes = {
  plain: "plain",
  start: "start",
  end: "end",
  wall: "wall",
  obstacleLight: "light",
  obstacleMedium: "medium",
  obstacleHeavy: "heavy",
  visitedCell: "visited",
  visitedLight: "visitedLight",
  visitedMedium: "visitedMedium",
  visitedHeavy: "visitedHeavy",
  shortestPathCell: "shortestPath"
};

/**
 * defines weight of obstacles
 */
const obstacleWeights = {
  wall: 1,
  light: 2,
  medium: 3,
  heavy: 4
};

/**
 * defines events used
 */
const events = {
  click: "click",
  load: "load"
};

/**
 * defines timeouts in ms for slow motion
 */
const timeouts = {
  default: 0.5,
  slow: 5,
  verySlow: 15
};

/**
 * defines size of grid/matrix
 */
const gridSize = {
  row: 24,
  column: 24
};

module.exports = {
  colors,
  htmlElement,
  events,
  timeouts,
  obstacleWeights,
  cellTypes,
  gridSize
};

},{}],11:[function(require,module,exports){
/**
 * executes all needed classes and functions for running the logic of path-finder
 */
let GuiController = require("./GuiController");

let guiController = new GuiController();
guiController.setup();

},{"./GuiController":8}]},{},[11]);
