(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = require('./lib/heap');

},{"./lib/heap":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);

},{}],3:[function(require,module,exports){
let alreadyExecuted = false;

let lastClicked;
let grid = createGrid(24, 24, function(el, row, col, i) {
  el.className = "clicked";
  // if (lastClicked) {
  // lastClicked.className = "";
  if (startPoint.x == undefined) {
    setStartPoint(col, row);
  } else if (endPoint.x == undefined) {
    setEndPoint(col, row);
  } else {
    // just temporary for starting algorithm
    if (col == 23 && row == 23 && !alreadyExecuted) {
      console.log("Starting algorithm");
      startAlgorithm();
      alreadyExecuted = true;
    } else if (col == 0 && row == 23 && alreadyExecuted) {
      clearGrid();
    } else {
      setWall(col, row);
    }
  }
  // }
  // lastClicked = el;
});

document.body.appendChild(grid);

let Grid = require("./grid");
let Dijkstra = require("./dijkstra");
let visited = [];
let timeout = 1; // in ms
let timeWaited = 0;
let startPoint = {
  x: undefined,
  y: undefined
};
let endPoint = {
  x: undefined,
  y: undefined
};
let walls = [];

/**
 * If walls are added, change matrix cell to 1
 */
let matrix = new Array(24);
for (i = 0; i < 24; i++) {
  matrix[i] = new Array(24);
  for (j = 0; j < 24; j++) {
    matrix[i][j] = 0;
  }
}

function createGrid(rows, cols, callback) {
  var i = 0;
  var grid = document.createElement("table");
  grid.className = "grid";
  for (var r = 0; r < rows; ++r) {
    var tr = grid.appendChild(document.createElement("tr"));
    for (var c = 0; c < cols; ++c) {
      var cell = tr.appendChild(document.createElement("td"));
      cell.addEventListener(
        "click",
        (function(el, r, c, i) {
          return function() {
            callback(el, r, c, i);
          };
        })(cell, r, c, i),
        false
      );
    }
  }
  return grid;
}

/**
 * Adds visited element to list
 */
function getVisitedElement(row, column) {
  visited.push({ x: row, y: column });
}

/**
 * Sets color of start and endpoint
 */
function setElement(x, y, isStart, isWall) {
  let element = grid.rows[x].cells[y];
  if (isWall) element.style.backgroundColor = "black";
  if (isStart) element.style.backgroundColor = "lightgreen";
  if (!isStart && !isWall) element.style.backgroundColor = "indianred";
}

let createMatrix = rows => {
  /**
   * If walls are added, change matrix cell to 1
   */
  let matrix = new Array(rows);
  for (i = 0; i < rows; i++) {
    matrix[i] = new Array(rows);
    for (j = 0; j < rows; j++) {
      matrix[i][j] = 0;
    }
  }
  return matrix;
};

let setStartPoint = (row, col) => {
  startPoint = { x: col, y: row };
  setElement(startPoint.x, startPoint.y, true);
  console.log(`startpoint: (${startPoint.x}, ${startPoint.y})`);
};

let setEndPoint = (row, col) => {
  endPoint = { x: col, y: row };
  setElement(endPoint.x, endPoint.y, false);
  console.log(`endpoint: (${endPoint.x}, ${endPoint.y})`);
};

let setWall = (row, col) => {
  console.log(`Wall: (${col}, ${row})`);
  walls.push({ x: col, y: row });
  matrix[row][col] = 1;
  setElement(col, row, false, true);
};

let clearGrid = () => {
  console.log("Clearing grid");
  startPoint = { x: undefined, y: undefined };
  endPoint = { x: undefined, y: undefined };
  walls = [];
  visited = [];

  for (let x = 0; x < matrix.length; x++) {
    for (let y = 0; y < matrix[0].length; y++) {
      grid.rows[x].cells[y].style.backgroundColor = "white";
    }
  }
  alreadyExecuted = false;
  matrix = createMatrix(24);
  timeWaited = 0;
};

let startAlgorithm = () => {
  let intputGrid = new Grid(matrix);

  let dijkstra = new Dijkstra();
  let shortestPath = dijkstra.findShortestPath(
    startPoint,
    endPoint,
    intputGrid,
    getVisitedElement
  );

  /**
   * Animation for visited cells
   */
  visited.forEach((node, index) => {
    if (node.x == endPoint.x && node.y == endPoint.y) return;
    if (node.x == startPoint.x && node.y == startPoint.y) return;
    setTimeout(() => {
      let element = grid.rows[node.x].cells[node.y];
      element.style.backgroundColor = "lightblue";
    }, index * timeout);
    timeWaited++;
  });

  /**
   * Draws shortest path
   */
  setTimeout(() => {
    shortestPath.forEach(node => {
      if (node.x == startPoint.x && node.y == startPoint.y) return;
      if (node.x == endPoint.x && node.y == endPoint.y) return;
      let element = grid.rows[node.x].cells[node.y];
      element.style.backgroundColor = "sandybrown";
    });
  }, timeWaited * timeout);
};

},{"./dijkstra":4,"./grid":5}],4:[function(require,module,exports){
var Heap = require("heap");

/**
 * Dijkstra algorithm based on:  https://github.com/bgrins/javascript-astar
 */
class Dijkstra {
  constructor(weight) {
    this.weight = weight == null ? 1 : weight;
  }

  /**
   * Find and returns the shortest path.
   */
  findShortestPath = (start, end, grid, getVisitedElement) => {
    let startNode = grid.getNode(start.x, start.y);
    let endNode = grid.getNode(end.x, end.y);
    let node, allCurrentNeighbors, neighbor;
    let nodeList = new Heap((first, next) => first.fCost - next.fCost);

    startNode.gCost = 0;
    startNode.fCost = 0;

    nodeList.push(startNode);
    startNode.opened = true;

    while (!nodeList.empty()) {
      // console.log(nodeList.peek());
      node = nodeList.pop(); // gets next node
      node.closed = true;

      // returns shortest path if end was reached
      if (node === endNode) return this.shortestPath(endNode);

      allCurrentNeighbors = grid.getNeighbors(node); // get neigbours of the current node
      for (let i = 0; i < allCurrentNeighbors.length; ++i) {
        neighbor = allCurrentNeighbors[i];
        if (neighbor.closed) continue;

        // get the distance between current node and the neighbor and calculate the next g score
        let nextGCost = node.gCost + 1; // only top/bottom/left/right movement

        // Check if neighbor was not visited yet and has smaller cost
        if (!neighbor.opened || nextGCost < neighbor.gCost) {
          neighbor.hCost = this.weight;
          neighbor.gCost = nextGCost;
          neighbor.fCost = neighbor.gCost + neighbor.hCost;
          neighbor.parent = node;

          nodeList.push(neighbor);
          getVisitedElement(neighbor.x, neighbor.y);
          neighbor.opened = true;
        }
      }
    }

    return null; // if it cannot find any path, return empty list
  };

  shortestPath = endNode => {
    let shortestPath = [{ x: endNode.x, y: endNode.y }];
    while (endNode.parent != null) {
      endNode = endNode.parent;
      shortestPath.push({ x: endNode.x, y: endNode.y });
    }
    let shortestPathReversed = shortestPath.reverse();
    return shortestPathReversed;
  };
}

module.exports = Dijkstra;

},{"heap":1}],5:[function(require,module,exports){
/**
 * The Grid class, encapsulates layout of nodes.
 */
class Grid {
  constructor(input) {
    this.height = input.length;
    this.width = input[0].length;

    this.nodes = this.buildNodesFromMatrix(input);
  }

  /**
   * Build and return the nodes.
   */
  buildNodesFromMatrix = matrix => {
    let nodes = new Array(this.height);

    for (let i = 0; i < this.height; ++i) {
      nodes[i] = new Array(this.width);
      for (let j = 0; j < this.width; ++j) {
        nodes[i][j] = new Node(j, i);
      }
    }

    for (let i = 0; i < this.height; ++i) {
      for (let j = 0; j < this.width; ++j) {
        if (matrix[i][j]) nodes[i][j].walkable = false; // everything != (0 || false) will be blocked
      }
    }
    return nodes;
  };

  /**
   * Returns cell of matrix [row][column]
   */
  getNode = (x, y) => {
    return this.nodes[y][x];
  };

  /**
   * Returns true if position is inside of the grid and walkable
   */
  walkable = (x, y) => {
    return this.insideGrid(x, y) && this.nodes[y][x].walkable;
  };

  /**
   * Determines whether position is inside grid.
   */
  insideGrid = (x, y) => {
    let withinXBorder = x >= 0 && x < this.width;
    let withinYBorder = y >= 0 && y < this.height;
    return withinXBorder && withinYBorder;
  };

  /**
   * Gets neighbors of node
   * @todo: add diagonal movement
   */
  getNeighbors = node => {
    let x = node.x;
    let y = node.y;
    let neighbors = [];
    let nodesList = this.nodes;

    // top
    let top = y - 1;
    if (this.walkable(x, top)) neighbors.push(nodesList[top][x]);

    // right
    let right = x + 1;
    if (this.walkable(right, y)) neighbors.push(nodesList[y][right]);

    // bottom
    let bottom = y + 1;
    if (this.walkable(x, bottom)) neighbors.push(nodesList[bottom][x]);

    // left
    let left = x - 1;
    if (this.walkable(left, y)) neighbors.push(nodesList[y][left]);

    return neighbors;
  };
}

function Node(x, y, walkable) {
  this.x = x;
  this.y = y;
  this.walkable = walkable === undefined ? true : walkable;
}

module.exports = Grid;

},{}]},{},[3]);
